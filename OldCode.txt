AudioService::
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using Plugin.Maui.Audio;
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace MauiAppMicrophone.Services
{
    public partial class AudioService : IAudioService
    {

        private readonly IAudioManager audioManager;
        private IAudioPlayer audioPlayer;
        private IAudioStreamer audioStreamer;



        private CancellationTokenSource? tokenSource;
        private MemoryStream capturedAudioStream;
        private readonly ConcurrentQueue<byte[]> _chunks = new();
        public bool IsPlaying { get; private set; }

        public AudioService(IAudioManager audioManager) {
            this.audioManager = audioManager;
        }



        public async Task PlayeAudio()
        {
            
            if (!IsPlaying)
            {
                IsPlaying = true;
                if (audioStreamer is null)
                {

                    audioStreamer = audioManager.CreateStreamer();
                    audioStreamer.Options.BitDepth = BitDepth.Pcm16bit;
                    audioStreamer.Options.Channels = ChannelType.Mono;
                    audioStreamer.Options.SampleRate = 16000;

                    audioStreamer.OnAudioCaptured += ListenSound;
                }
                /* я так пологаю это мы получаем поток аудио в байтах*/
                //подписываемся на событие
                tokenSource = new CancellationTokenSource();
                await audioStreamer.StartAsync();
                _= BackgroundPlayer(tokenSource.Token);
            }
            else
            {
                if (tokenSource!=null)
                {

                    await tokenSource.CancelAsync();
                }
                await audioStreamer.StopAsync();
                IsPlaying = false;
            }
        }



        private void GenerateMemoryStream()
        {
            if (capturedAudioStream is not null)
            {
                capturedAudioStream.Dispose();
            }
            capturedAudioStream = new MemoryStream();
            while (_chunks.TryDequeue(out byte[] buffer)) {
                capturedAudioStream.Write(buffer, 0, buffer.Length);
            }
        }



        public async Task BackgroundPlayer(CancellationToken ct)
        {
            try
            {

                if(audioPlayer is null)
                {
                    //  AudioManager
                    /* а это проигрыватель звука не до конца разобразлся как с ним работать*/

                    audioPlayer = audioManager.CreatePlayer();
                }
                await Task.Delay(TimeSpan.FromSeconds(5));
                while (!ct.IsCancellationRequested) 
                {
                    if (!audioPlayer.IsPlaying)
                    {
                        GenerateMemoryStream();
                        audioPlayer.SetSource(capturedAudioStream);
                        audioPlayer.Play();
                    }
                    await Task.Delay(TimeSpan.FromMilliseconds(500));
                }
            }
            catch (OperationCanceledException ex)
            {
                await Shell.Current.DisplayAlert("Error OperationCanceledException", ex.Message,"ok");
            }
            catch (Exception ex)
            {

                await Shell.Current.DisplayAlert("Error Exception", ex.Message, "ok");
            }
            finally
            {

                if (audioPlayer is not null)
                {
                    audioPlayer.Dispose();
                }
                tokenSource.Dispose();
                tokenSource = null;
            }
        }

        private void ListenSound(object? sender, AudioStreamEventArgs e)
        {
            var bytes=e.Audio;//Audio это массив байтов
            _chunks.Enqueue(bytes);
          //  capturedAudioStream.Write(bytes, 0, bytes.Length);
        }

    
       
    }
}


NAudioService::

using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using NAudio.Wave;
using Plugin.Maui.Audio;
using Plugin.Maui.Audio.AudioListeners;
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Channels;
using System.Threading.Tasks;

namespace MauiAppMicrophone.Services
{
    public partial class NAudioService: IAudioService
    {

        private readonly IAudioManager audioManager;
        private readonly WaveInEvent inWave;
        private IAudioPlayer audioPlayer;
        //  private PcmAudioHandler pcmAudioHandler;
        
        
        
        private readonly object _processingLock = new object();
        private CancellationTokenSource? tokenSource;
        private MemoryStream capturedAudioStream;
        private MemoryStream audioStream;
        private readonly ConcurrentQueue<byte[]> _chunks = new();

        // НАСТРОЙКИ
        private const int TARGET_LATENCY_MS = 200;  // Целевая задержка 250 мс
        private const int CHUNK_SIZE_MS = 50;       // Размер чанка 50 мс


        private int sampleRate=44000;
        public bool IsPlaying { get; private set; }
        private int chunkSizeBytes;
        private int bufferTargetBytes;

        public NAudioService(IAudioManager audioManager)
        {
            int bytesPerSecond = sampleRate * (16 / 8) * 1;
            chunkSizeBytes = (bytesPerSecond * CHUNK_SIZE_MS) / 1000;
            bufferTargetBytes = (bytesPerSecond * TARGET_LATENCY_MS) / 1000;
            inWave =new WaveInEvent()
            {
                DeviceNumber = 0,
                WaveFormat = new WaveFormat(rate: sampleRate, bits: 16, channels: 1),
                BufferMilliseconds = CHUNK_SIZE_MS
            };
           // pcmAudioHandler = new PcmAudioHandler(sampleRate, ChannelType.Mono, BitDepth.Pcm16bit);
            inWave.DataAvailable += ListenSound;
            audioStream=new MemoryStream();
            capturedAudioStream=new MemoryStream();
            this.audioManager = audioManager;
        }

        void WriteAudioAsWavFile(byte[] audio, int sampleRate, ChannelType channels, BitDepth bitDepth)
        {
            var header = PcmAudioHelpers.CreateWavFileHeader(audio.Length, sampleRate, (int)channels, (int)bitDepth);

            //if (capturedAudioStream is not null)
            //{
            //    capturedAudioStream.Dispose();
            //}
            //capturedAudioStream = new MemoryStream();
            //
            capturedAudioStream.SetLength(0);
            capturedAudioStream.Position = 0;
            capturedAudioStream.Write(header);
            capturedAudioStream.Write(audio);
           // capturedAudioStream.Close();
        }





        private void ListenSound(object? sender, WaveInEventArgs e)
        {
            //_chunks.Enqueue(e.Buffer);

            //var bufferCopy = new byte[e.BytesRecorded];
            //Array.Copy(e.Buffer, bufferCopy, e.BytesRecorded);
            audioStream.Position= audioStream.Length;
             audioStream.Write(e.Buffer, 0, e.BytesRecorded);//
            if (chunkSizeBytes <= audioStream.Length)
            {

                GenerateMemoryStream();
            }
            //
            //_chunks.Enqueue(bufferCopy);
        }


        private void ClearMainBuffer()
        {
            audioStream.SetLength(0);
            audioStream.Position = 0;
        }
        private void GenerateMemoryStream()
        {
            //var audioFileStream = new MemoryStream();
            //while (_chunks.TryDequeue(out byte[] buffer))
            //{
            //    audioFileStream.Write(buffer, 0, buffer.Length);
            //}
            WriteAudioAsWavFile(audioStream.ToArray(),sampleRate,ChannelType.Mono,BitDepth.Pcm16bit);

            //audioStream.Dispose();
            //audioStream = new MemoryStream();
            //capturedAudioStream.Position = 0;
        }



        public async Task BackgroundPlayer(CancellationToken ct)
        {
            try
            {

                if (audioPlayer is null)
                {
                    //  AudioManager
                    /* а это проигрыватель звука не до конца разобразлся как с ним работать*/

                    audioPlayer = audioManager.CreatePlayer();
                }
              //  await Task.Delay(TimeSpan.FromMilliseconds(TARGET_LATENCY_MS));
                while (!ct.IsCancellationRequested)
                {
                    if (!audioPlayer.IsPlaying&& capturedAudioStream.Length>0)
                    {

                        
                        audioPlayer.SetSource(capturedAudioStream);
                        audioPlayer.Play();
                        ClearMainBuffer();
                    }
                    await Task.Delay(TimeSpan.FromMilliseconds(CHUNK_SIZE_MS*3));
                }
            }
            catch (OperationCanceledException ex)
            {
                await Shell.Current.DisplayAlert("Error OperationCanceledException", ex.Message, "ok");
            }
            catch (Exception ex)
            {

                await Shell.Current.DisplayAlert("Error Exception", ex.Message, "ok");
            }
            finally
            {

                if (audioPlayer is not null)
                {
                    audioPlayer.Dispose();
                }
                tokenSource.Dispose();
                tokenSource = null;
            }
        }


        public async Task PlayeAudio()
        {
            if (!IsPlaying)
            {
                inWave.StartRecording();
                IsPlaying=true;
                tokenSource = new CancellationTokenSource();

                _ = BackgroundPlayer(tokenSource.Token);
            }
            else
            {
                if (tokenSource != null)
                {

                    await tokenSource.CancelAsync();
                }
                inWave.StopRecording();
                IsPlaying = false;

            }
        }
    }
}

